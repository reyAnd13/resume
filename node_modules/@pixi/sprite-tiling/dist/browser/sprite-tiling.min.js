/*!
 * @pixi/sprite-tiling - v6.0.4
 * Compiled Tue, 11 May 2021 18:00:23 UTC
 *
 * @pixi/sprite-tiling is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
this.PIXI=this.PIXI||{};var _pixi_sprite_tiling=function(t,r,e,n,o,i){"use strict";var a=function(t,r){return(a=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,r){t.__proto__=r}||function(t,r){for(var e in r)r.hasOwnProperty(e)&&(t[e]=r[e])})(t,r)};function s(t,r){function e(){this.constructor=t}a(t,r),t.prototype=null===r?Object.create(r):(e.prototype=r.prototype,new e)}var u=new e.Point,h=function(t){function n(n,o,i){void 0===o&&(o=100),void 0===i&&(i=100);var a=t.call(this,n)||this;return a.tileTransform=new e.Transform,a._width=o,a._height=i,a.uvMatrix=a.texture.uvMatrix||new r.TextureMatrix(n),a.pluginName="tilingSprite",a.uvRespectAnchor=!1,a}return s(n,t),Object.defineProperty(n.prototype,"clampMargin",{get:function(){return this.uvMatrix.clampMargin},set:function(t){this.uvMatrix.clampMargin=t,this.uvMatrix.update(!0)},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"tileScale",{get:function(){return this.tileTransform.scale},set:function(t){this.tileTransform.scale.copyFrom(t)},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"tilePosition",{get:function(){return this.tileTransform.position},set:function(t){this.tileTransform.position.copyFrom(t)},enumerable:!1,configurable:!0}),n.prototype._onTextureUpdate=function(){this.uvMatrix&&(this.uvMatrix.texture=this._texture),this._cachedTint=16777215},n.prototype._render=function(t){var r=this._texture;r&&r.valid&&(this.tileTransform.updateLocalTransform(),this.uvMatrix.update(),t.batch.setObjectRenderer(t.plugins[this.pluginName]),t.plugins[this.pluginName].render(this))},n.prototype._calculateBounds=function(){var t=this._width*-this._anchor._x,r=this._height*-this._anchor._y,e=this._width*(1-this._anchor._x),n=this._height*(1-this._anchor._y);this._bounds.addFrame(this.transform,t,r,e,n)},n.prototype.getLocalBounds=function(r){return 0===this.children.length?(this._bounds.minX=this._width*-this._anchor._x,this._bounds.minY=this._height*-this._anchor._y,this._bounds.maxX=this._width*(1-this._anchor._x),this._bounds.maxY=this._height*(1-this._anchor._y),r||(this._localBoundsRect||(this._localBoundsRect=new e.Rectangle),r=this._localBoundsRect),this._bounds.getRectangle(r)):t.prototype.getLocalBounds.call(this,r)},n.prototype.containsPoint=function(t){this.worldTransform.applyInverse(t,u);var r=this._width,e=this._height,n=-r*this.anchor._x;if(u.x>=n&&u.x<n+r){var o=-e*this.anchor._y;if(u.y>=o&&u.y<o+e)return!0}return!1},n.prototype.destroy=function(r){t.prototype.destroy.call(this,r),this.tileTransform=null,this.uvMatrix=null},n.from=function(t,e){return new n(t instanceof r.Texture?t:r.Texture.from(t,e),e.width,e.height)},Object.defineProperty(n.prototype,"width",{get:function(){return this._width},set:function(t){this._width=t},enumerable:!1,configurable:!0}),Object.defineProperty(n.prototype,"height",{get:function(){return this._height},set:function(t){this._height=t},enumerable:!1,configurable:!0}),n}(n.Sprite),c="attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n",l="varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture2D(uSampler, coord);\n    gl_FragColor = texSample * uColor;\n}\n",d="varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 sample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = sample * uColor;\n}\n",p=new e.Matrix,m=function(t){function e(e){var n=t.call(this,e)||this,o={globals:n.renderer.globalUniforms};return n.shader=r.Shader.from(c,l,o),n.simpleShader=r.Shader.from(c,d,o),n.quad=new r.QuadUv,n.state=r.State.for2d(),n}return s(e,t),e.prototype.render=function(t){var r=this.renderer,e=this.quad,n=e.vertices;n[0]=n[6]=t._width*-t.anchor.x,n[1]=n[3]=t._height*-t.anchor.y,n[2]=n[4]=t._width*(1-t.anchor.x),n[5]=n[7]=t._height*(1-t.anchor.y);var a=t.uvRespectAnchor?t.anchor.x:0,s=t.uvRespectAnchor?t.anchor.y:0;(n=e.uvs)[0]=n[6]=-a,n[1]=n[3]=-s,n[2]=n[4]=1-a,n[5]=n[7]=1-s,e.invalidate();var u=t._texture,h=u.baseTexture,c=t.tileTransform.localTransform,l=t.uvMatrix,d=h.isPowerOfTwo&&u.frame.width===h.width&&u.frame.height===h.height;d&&(h._glTextures[r.CONTEXT_UID]?d=h.wrapMode!==o.WRAP_MODES.CLAMP:h.wrapMode===o.WRAP_MODES.CLAMP&&(h.wrapMode=o.WRAP_MODES.REPEAT));var m=d?this.simpleShader:this.shader,f=u.width,_=u.height,v=t._width,x=t._height;p.set(c.a*f/v,c.b*f/x,c.c*_/v,c.d*_/x,c.tx/v,c.ty/x),p.invert(),d?p.prepend(l.mapCoord):(m.uniforms.uMapCoord=l.mapCoord.toArray(!0),m.uniforms.uClampFrame=l.uClampFrame,m.uniforms.uClampOffset=l.uClampOffset),m.uniforms.uTransform=p.toArray(!0),m.uniforms.uColor=i.premultiplyTintToRgba(t.tint,t.worldAlpha,m.uniforms.uColor,h.alphaMode),m.uniforms.translationMatrix=t.transform.worldTransform.toArray(!0),m.uniforms.uSampler=u,r.shader.bind(m),r.geometry.bind(e),this.state.blendMode=i.correctBlendMode(t.blendMode,h.alphaMode),r.state.set(this.state),r.geometry.draw(this.renderer.gl.TRIANGLES,6,0)},e}(r.ObjectRenderer);return t.TilingSprite=h,t.TilingSpriteRenderer=m,t}({},PIXI,PIXI,PIXI,PIXI,PIXI.utils);Object.assign(this.PIXI,_pixi_sprite_tiling);
//# sourceMappingURL=sprite-tiling.min.js.map
